# Отчёт по лабораторной работе по DevOps №2
## Содержание:
- [Установка Docker на Ubuntu](#установка-docker-на-ubuntu)
- ["Bad" Dockerfile](#bad-dockerfile)
- ["Good" Dockerfile](#good-dockerfile)
- ["Bad Guys" в контейнерах](#bad-guys-в-контейнерах)

## Установка Docker на Ubuntu
Ниже описываем все шаги, как мы скачивали Docker:

`sudo apt update` - обновляем списки пакетов из репозиториев

`sudo apt install apt-transport-https ca-certificates curl software-properties-common` - установливаем пакеты, которые необходимы для работы пакетного менеджера apt по протоколу HTTPS

`curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -` - добавляем GPG-ключ репозитория Docker

`sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"` - добавляем репозиторий Docker

`sudo apt update` - ещё раз обновляем пакеты

`apt-cache policy docker-ce` - переключаемся в репозиторий Docker, чтобы его установить

`sudo apt install docker-ce` - устанавливаем Docker

`sudo systemctl status docker` - проверяем работоспособность программы

Всё хорошо!

![image_2024-10-06_18-24-22](https://github.com/user-attachments/assets/0efa1b27-76cd-4ab5-8255-02d8abf6e7c2)

`docker run hello-world` - проверяем доступ к образам Docker

С нами поздоровались, значит, всё супер!

![IMG_9390](https://github.com/user-attachments/assets/fe63c78f-46fc-4794-a7cb-63527827c2e1)

## "Bad" Dockerfile
![IMG_9391](https://github.com/user-attachments/assets/6c452e40-1917-4160-ab08-4c5d511bdea9)

Что же такого **"bad"** в этом файле?

1. Тег latest
```
FROM ubuntu:latest
```   
Тег latest всегда указывает на последнюю версию доступного образа Ubuntu, но если базовый образ обновится, то написанный Dockerfile может перестать работать: появятся проблемы с совместимостью и непрезсказуемое поведение в работе с контейнерами.
   
2. Размножение инструкций
```
RUN apt-get update
RUN apt-get install bash
```
Размножать инструкции RUN, COPY или ADD не стоит, так как из-за этого создаются лишние слои, что приводит к увеличению размера образа, так как слои кэшируются. По-хорошему нужно минимизировать количество слоев образа и сделать код более читаемым.
   
3. Отсутствие рабочего каталога
   
Инструкция WORKDIR устанавливает рабочий каталог контейнера, а последующие команды наследуют привязку WORKDIR. Лучше сохранять все исходные файлы в отдельной папке в корневом каталоге, чем размещать их там же, где находятся системные файлы. Это снижает риск случайного повреждения образа при удалении.

## "Good" Dockerfile
![IMG_9392](https://github.com/user-attachments/assets/8d00bf7f-2b54-4c22-b84d-b8d3a095f69d)

Что стало **"good"**?

1. Определенный базовый образ
```
FROM ubuntu:22.04
```
Мы изменили базовый образ на определенную версию (Ubuntu 22.04), и теперь он не сможет обновиться самостоятельно.
   
2. Одна инструкция
```
RUN apt-get update && apt-get install bash
```
Здесь мы избавились от ненужных нам слоев, создаваемых еще одной инструкцией RUN, и теперь всё указано в одном месте, код стал более читаемым.
   
3. Рабочий каталог
```
WORKDIR /lab-2
```
Добавили рабочий каталог, тем самым избавившись от случайных рисков и добавив ясности и прозрачности (куда класть файлы, чтобы они не потерялись).

## "Bad Guys" в контейнерах

![image](https://github.com/user-attachments/assets/66841683-5e5d-4415-94bb-9b1dcc4743af)

**1. Отсутствие мониторинга контейнеров**
   
   Запуск контейнеров без мониторинга их состояния и ресурсов может привести, например, к деградации производительности на хосте или даже к отказу всего сервера. В худшем случае еще и к проблемам с другими контейнерами, запущенными на том же хосте.

**2. Неиспользование ограничений по ресурсам (CPU и память)**
   
   Если запускать контейнеры без установленных лимитов на использование процессора и памяти, то один контейнер может начать потреблять слишком много ресурсов, забирая их у других процессов на хосте. А это приводит к проблемам с производительностью всей системы. Для решения проблемы можно устанавливать ограничения при запуске с помощью флагов --memory и --cpus.

---

![image](https://github.com/user-attachments/assets/6af77ae2-799c-4919-932d-e091090861e3)
![image](https://github.com/user-attachments/assets/95aa0666-c89d-43ea-93e3-c60af059e5c0)



# Отчёт по лабораторной работе по DevOps №2⭐
## Содержание:
- ["Bad" Docker-compose](#bad-docker-compose)
- ["Good" Docker-compose](#good-docker-compose)
- [Изоляция контейнеров](#изоляция-контейнеров)

## "Bad" Docker-compose

`nano docker-compose.yml` - создаем файл Docker-compose

![IMG_9573](https://github.com/user-attachments/assets/380e1b9d-ab0d-4275-8102-d82e04ddf260)

Что же такого **"bad"** в этом файле?

1. Стандартный порт
```
ports:
  - "80:80"
```
Не стоит использовать явный порт для http, так как это может привести к конфликтам с другими серверами на том же порту.

2. Локальный том
```
volumes:
  - ./app:/usr/scr/app
```
Исппользование локальных томов для базы данных может привести к рискам безопасности и потери данных при переносе.

3. Отсутствие networks

Сети позволяют сервисам общаться между собой. Поместив несколько сервисов в один network, они могут свободно обращаться друг к другу по названию сервиса. Это удобно и быстро конфигурируется, что делает деплой приложения в Docker простым.

## "Good" Docker-compose
![IMG_9574](https://github.com/user-attachments/assets/a90cda72-8eae-47b6-8671-95c5d251a9d2)

Что стало **"good"**?

1. Нестандартный порт
```
ports:
  - "8080:80"
```
Теперь мы можем не бояться конфликтов с другими серверами на хосте, так как теперь наш порт нестандартный.

2. Именной том
```
volumes:
  - app-data:/usr/scr/app
```
```
volumes:
  app-data:
```
Мы поместили данные в именной том для указания явного пути, что позволяет лучше управлять данными, изолировать их от хоста и повысить безопасность.

3. Добавление сетей
```
networks:
  - app_network
```
```
networks:
  - db_network
```
```
networks:
  app_network:
    driver: bridge
  db_network:
    driver: bridge
```
Теперь у каждого контейнера есть своя сеть. В дальнейшем при создании новых контейнеров мы можем приписать к ним уже существующую сеть, чтобы они могли свободно обращаться друг к другу.

## Изоляция контейнеров

Тут мы поняли, что уже изолировали наши контейнеры, когда создавали отдельные сети app_network и db_network. Раз у каждого своя сеть, то они не могут взаимодействовать друг с другом напрямую. При этом они все равно могут работать одновременно. Принцип изоляции повышает безопасность и контроль сети.
